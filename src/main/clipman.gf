/*	
 //!GFG и //!\GFG  are commentary attributes generated by 
 the Gentee form editor. You should neither delete them 
 nor make any changes into the source code from the beginning 
 of the commentary attribute //!GFG to its end //!\GFG
*/

//!GFG include
include {
	"app.g"
	"popupmenu.g"
	"menu.g"
	"tray.g"
//!\GFG
   $"..\gentee-lib\app\comp2gt.g"
   $"..\gentee-lib\dialogs\prefs.gf"
   //"notice.gf"
   "histitem.gf"
   "btnlist.gf"    
}

import "user32.dll"
{
   uint MessageBeep(uint)
   uint GetKeyboardState(uint)
   uint ActivateKeyboardLayout( uint, uint )
   uint AttachThreadInput(uint,uint,uint)
   uint LoadKeyboardLayoutA(uint,uint)
   uint GetKeyboardLayout(uint)
}


//!GFG form
type vfClipMan <inherit=vForm> {
	vTray	Tray0
	vPopupMenu	pmTray
	vMenuItem	miTrayExit
	vMenuItem	mPref
	vMenuItem	mAbout
	vMenu	Menu0
	vMenuItem	MenuItem0
	vMenuItem	MenuItem1
 //!\GFG
   uint flgExit
/*   sqlite      sqlg
   sqlite      sqli
   sqlite      sqlf
   sqlite      sqlq 
*/   
   uint hhkspeedcopy
      
   uint hhkspeedpaste
   
   
   uint hkspeedcopy
   uint hkspeedpaste   
   uint maxitemsize
   uint maxhistsize 
   uint pastetotop 
    
   uint p_ctrllayout
   uint p_ctrlshow
   uint p_hotkeyshow_key
   uint p_hotkeyshow_mstate
   uint p_shownearcursor
   
   arr         dynamics of uint
   ustr dbpath
   
   uint ctrlstart
   uint ctrlshowstart
   uint otherstart
   uint testmove
   uint testtray
   uint hwndtray
}



define {
   HISTORY = 0
   FAST    = 1
   NOTICE  = 2
}

extern {
method vfClipMan.RefreshNotices( uint curid )
method vfClipMan.CopyTo( uint srctable, uint srcid, uint desttable, uint destownerid )
method vfClipMan.DeleteItem( uint table, uint id, uint refresh )
method vfClipMan.EditItem( vForm form, uint table, uint id, vToolBarItem item )
//method vfClipMan.ItemRefreshFormats( vfItemDot itemdot )
method vfClipMan.ItemLoad( vForm card, uint table, uint id )
method vfClipMan.HideShow( uint show )
}

global
{
   vfClipMan fClipMan
   arrstr tables[3] 
   collection dynnames = %{"history", "fast", "search"}
}
include {
$"cliptools.gf"
}
global
{  
   str sftools = "fTools"
   
   vfHistItem fHistItem
   vfHistItem fHistItemCard
}




method uint vfClipMan.PrefChanged <alias=fClipMan_PrefChanged>( evparValColl evc )
{
   
   str val = evc.val[1]->ustr.str()
   
   switch evc.val[0]->str
   {
      case "language" 
      {
         if App.Lng.curlang != val
         { 
            App.Lng.change( val )
            App.Virtual( $mLangChanged )
         }
      }
      case "autorun"
      {
         ustr  subkey = $"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
         ustr  valname = PROGDIR
         if val.uint()
         {        
            uint z=getmodulename("").ustr().regset( /*$HKEY_LOCAL_MACHINE*/$HKEY_CURRENT_USER, subkey, valname )
         }
         else
         {      
            regdelvalue( $HKEY_LOCAL_MACHINE, subkey, valname )
         }
      }
      case "ctrllayout"
      {
         .p_ctrllayout = val.uint()
      }
      case "ctrlshow"
      {
         .p_ctrlshow = val.uint()
      }
      case "histlen"
      {
         fClipTools.SetMaxRows( val.uint() )
      }
      case "hotkeyshow"
      {   
         shortkey sk      
         sk.caption = val
         
         .p_hotkeyshow_key = sk.key         
         .p_hotkeyshow_mstate = sk.mstate         
      }
      
      case "shownearcursor"
      {
         uint newval = val.uint()
         if .p_shownearcursor != newval
         {
            .p_shownearcursor = newval
         }
      }
      case "hkspeedpaste"
      {
         shortkey sk      
         sk.caption = val      
         uint key = (sk.mstate << 12) | sk.key
         if .hkspeedpaste != key
         {
            .hkspeedpaste = key
            //if .hhkspeedpaste : keyunhook( .hhkspeedpaste )
            //.hhkspeedpaste = keyhook( .hwnd, key )                
         }
      }
      case "maxitemsize"
      {
         .maxitemsize = val.uint() * 1024
      }
      case "maxhistsize"
      {
         val = (max( val.uint(), 100 )).str()
         .maxhistsize = val.uint() 
      }      
      case "pastetotop"
      {
         .pastetotop = val.uint()
      }
   }   
   return 0
}

type MOUSEHOOKSTRUCT {
  POINT     pt
  uint      hwnd
  uint      wHitTestCode
  uint      dwExtraInfo
} 

type MSLLHOOKSTRUCT {
  POINT    pt
  uint     mouseData
  uint     flags
  uint     time
  uint     dwExtraInfo
} 

type KBDLLHOOKSTRUCT {
  uint     vkCode
  uint     scanCode
  uint     flags
  uint     time
  uint     dwExtraInfo
}

method uint vfClipMan.ShowHide()
{
   if !fClipTools.Visible && .p_shownearcursor
   {
      POINT p
      GetCursorPos( p )
      fClipTools.Left = p.x - 15
      
      RECT r
      GetWindowRect( GetDesktopWindow(), r )
      fClipTools.Top = min(p.y - 30,r.bottom-300)
   }
   fClipTools.Visible = !fClipTools.Visible
   fClipTools.CheckPos()
   return 0
}


method uint vfClipMan.keyllhook <alias=vfClipMan_KeyLLHook>( winmsg msg )//!\GFG
{
   uint ret = 0   
   if msg.lpar->KBDLLHOOKSTRUCT.flags & 0x10 : return 0
   if .p_ctrllayout && msg.lpar->KBDLLHOOKSTRUCT.vkCode == 163 //right control
   {  
      if msg.lpar->KBDLLHOOKSTRUCT.flags & 0x80  //LLKHF_UP
      {         
         if .ctrlstart && ( msg.lpar->KBDLLHOOKSTRUCT.time - .ctrlstart < $KEYTIMEOUT )
         {  
             
            uint hwnd=GetForegroundWindow()
            while 1
            {
               ustr name
               name.reserve(512)
               GetClassName(hwnd,name.ptr(), 512)
               name.setlenptr()
               //print( "tt 1 \(hwnd) \(name.str())\n")
               if name.str()== "#32770"
               {  
                  uint newhwnd = GetParent(hwnd)//GetWindow(hwnd,4)// 
                  if newhwnd
                  {
                     //print( "z1\n") 
                     hwnd = newhwnd                        
                  }  
                  else
                  {
                     uint thisthread = GetCurrentThreadId()
                     uint curthread = GetWindowThreadProcessId(hwnd,0)
                     uint z = AttachThreadInput( thisthread, curthread, 1)               
                     hwnd = GetFocus()               
                     z = AttachThreadInput( thisthread, curthread, 0) 
                     break
                  }
               }
               else
               {                       
                  break
               }
            }
            PostMessage(hwnd, 0x0050, 2, 0)//WM_INPUTLANGCHANGEREQUEST 
         }
         .ctrlstart = 0
         
      }
      else
      {
         if !.ctrlstart
         {
            .ctrlstart = msg.lpar->KBDLLHOOKSTRUCT.time
         }      
      }
   }   
   elif .p_ctrlshow && msg.lpar->KBDLLHOOKSTRUCT.vkCode == 162 //left control
   {  
      //print( "SC =\(msg.lpar->KBDLLHOOKSTRUCT.scanCode) flags = \(msg.lpar->KBDLLHOOKSTRUCT.flags) dwExtraInfo = \(msg.lpar->KBDLLHOOKSTRUCT.dwExtraInfo)\n" )
      if msg.lpar->KBDLLHOOKSTRUCT.flags & 0x80 //LLKHF_UP
      {       
         if .ctrlshowstart && ( msg.lpar->KBDLLHOOKSTRUCT.time - .ctrlshowstart < $KEYTIMEOUT ) &&
            ( msg.lpar->KBDLLHOOKSTRUCT.time - .ctrlshowstart > 50 )
         {    
            //print( "up \(msg.lpar->KBDLLHOOKSTRUCT.time) \(.ctrlshowstart)\n" )        
            .ShowHide()
            ret = 1
         }         
         .ctrlshowstart = 0
      }
      else
      {                
         if !.ctrlshowstart
         {
            //print( "down \(msg.lpar->KBDLLHOOKSTRUCT.time) \(.ctrlshowstart)\n" )
            .ctrlshowstart = msg.lpar->KBDLLHOOKSTRUCT.time
         }             
      }
   }
   else
   {
      .ctrlstart = 0
      .ctrlshowstart = 0
   }
   
      if msg.lpar->KBDLLHOOKSTRUCT.vkCode == .p_hotkeyshow_key &&
         !(msg.lpar->KBDLLHOOKSTRUCT.flags & 0x80) 
      {
         uint mstate = 0
         uint pb = msg.wpar         
         if (pb+$VK_LCONTROL)->byte : mstate |= $mstCtrl
         if (pb+$VK_RCONTROL)->byte : mstate |= $mstCtrl
         if (pb+$VK_CONTROL)->byte : mstate |= $mstCtrl
         if (pb+$VK_LSHIFT)->byte : mstate |= $mstShift
         if (pb+$VK_RSHIFT)->byte : mstate |= $mstShift
         if (pb+$VK_SHIFT)->byte : mstate |= $mstShift
         if (pb+$VK_LMENU)->byte : mstate |= $mstAlt
         if (pb+$VK_RMENU)->byte : mstate |= $mstAlt
         if (pb+$VK_MENU)->byte : mstate |= $mstAlt
         if (pb+$VK_LWIN)->byte : mstate |= $mstWin
         if (pb+$VK_RWIN)->byte : mstate |= $mstWin
         if (pb+$VK_APPS)->byte : mstate |= $mstWin
         if mstate == .p_hotkeyshow_mstate//cnt == 1 && (last == 164 || last == 165 )
         {
            .ShowHide()
            msg.flags = 1
            ret = 1
         }
      }
      
   
   return ret 
}   
         
   
method uint vfClipMan.hook <alias=vfClipMan_Hook>( winmsg msg )//!\GFG
{
   
   if msg.wpar == fClipTools.blHistory.tbItems.hwnd
   {
      if y != GetForegroundWindow()
      {
      y = GetForegroundWindow()  
      if x : DestroyWindow(x)
      x = CreateWindowEx( $WS_EX_TOPMOST,
            "GVForm".ustr().ptr(), 0, $WS_POPUP, 0, 0, 10, 10, y, 0, 0, 0 )
      }
      return 1
   }
   
   return 0
}   

method uint vfClipMan.hookmouse <alias=vfClipMan_HookMouse>( winmsg msg )//!\GFG
{
   
   //print( "clearhook \(msg.lpar->KBDLLHOOKSTRUCT.time) \(.ctrlshowstart)\n" )
   if .ctrlstart 
   { 
      .ctrlstart -= $KEYTIMEOUT
   }
   if .ctrlshowstart
   {      
      .ctrlshowstart -= $KEYTIMEOUT
   }         
   return 0
}

method uint vfClipMan.mousewheel <alias=vfClipMan_MouseWheel>( winmsg msg )//!\GFG
{
   if msg.wpar == $WM_MOUSEWHEEL
   {
      //print( "clear \(msg.lpar->KBDLLHOOKSTRUCT.time) \(.ctrlshowstart)\n" )
   } 
   if msg.wpar == $WM_MOUSEWHEEL && fClipTools.Visible
   {
      POINT p   
      GetCursorPos( p )
      uint res = ScreenToClient( fClipTools.Tab0.hwnd, p )     
      if res && p.x > 0 && p.y > 0 && p.x < fClipTools.Tab0.Width && p.y < fClipTools.Tab0.Height
      {  
         int x = msg.lpar->MSLLHOOKSTRUCT.mouseData 
         SendMessage( fClipTools.blHistory.sbMain.hwnd, $WM_VSCROLL, ?(x>0, $SB_PAGEUP, $SB_PAGEDOWN), 0 )
         msg.flags = 1
         return 1      
      }
   }
   elif msg.wpar == $WM_MOUSEMOVE
   {
      POINT p
      RECT  r
      GetCursorPos( p )
      GetWindowRect( .hwndtray, r )
      if p.x >= r.left && p.y >= r.top && p.x < r.right && p.y < r.bottom
      {         
         .testmove = msg.lpar->MSLLHOOKSTRUCT.time
      }
   }
   elif msg.wpar == $WM_LBUTTONDOWN
   {
      if msg.lpar->MSLLHOOKSTRUCT.time - .testtray < $KEYTIMEOUT
      { 
         POINT p
         RECT  r
         GetCursorPos( p )
         GetWindowRect( .hwndtray, r )
         if p.x >= r.left && p.y >= r.top && p.x < r.right && p.y < r.bottom
         {  
            .testtray = 0
            fClipTools.Visible = !fClipTools.Visible
            fClipTools.CheckPos()
            msg.flags = 1         
            return 1
         }
      }      
   }         
   return 0
}


//!GFG method Create evparEvent
method uint vfClipMan.Create <alias=fClipMan_Create>( evparEvent evn )//!\GFG
{   
   ustr st = "Shell_TrayWnd"
   ustr tn = "TrayNotifyWnd"
   ustr sp = "SysPager"
   ustr tb = "ToolbarWindow32"
   .hwndtray = FindWindowEx(FindWindowEx(FindWindowEx(FindWindowEx(0,0,st.ptr(),0),0,tn.ptr(),0),0,sp.ptr(),0),0,tb.ptr(),0)   
   this.pTypeDef->tTypeDef.setproc( 0x402, vfClipMan_Hook )
   this.pTypeDef->tTypeDef.setproc( 0x404, vfClipMan_HookMouse )
   
   this.pTypeDef->tTypeDef.setproc( 0x403, vfClipMan_KeyLLHook )
   this.pTypeDef->tTypeDef.setproc( 0x405, vfClipMan_MouseWheel )
   
   
   fPrefs.OnChanged.Set( this, fClipMan_PrefChanged )
   fPrefs.SetPref( "<project>
   <settings group=1 label=settings help =\"preferences\">
      <fields>
         <language label=language req=1 ctrl=combobox custom=langs labpos=left  
                 width = 200 >            
            <default>english</>         
         </>
         <autorun label=autorun req=1 ctrl=checkbox labpos=left>         
            <default>0</>
         </>
         <histlen label=histlen req=1 ctrl=combobox labpos=left  
                 width = 200 sorted=0>            
            <default>25</>         
            <items>
               <5 label = 5>5</>
               <10 label = 10>10</>
               <25 label = 25>25</>
               <50 label = 50>50</>
               <100 label = 100>100</>
               <200 label = 200>200</>               
            </>
         </>         
         <hotkeyshow label=hotkeyshow req=1 ctrl=hotkey labpos=left width = 200>
         <default>Alt+Z</>
         </>
         <ctrlshow label=ctrlshow req=1 ctrl=checkbox labpos=left>         
            <default>1</>
         </>
         <shownearcursor label=shownearcursor req=1 ctrl=checkbox labpos=left>
         <default>1</>
         </>
         <optionally ctrl=text style=inversebold indent=3>optionally
         </>         
         <ctrllayout label=ctrllayout req=1 ctrl=checkbox labpos=left>         
            <default>0</>
         </>                                                        
      </>      
   </>
</>")

   fPrefs.Start( prefs )
   
   fClipTools.Owner = App
   forceforeground( this.hwnd )
   hookstart( this.hwnd )
return 0
}

//ѕоказать/скрыть //окно инструментов
method vfClipMan.HideShow( uint show )
{  
   //with fClipTools
   {
      if show//.Visible 
      {      
         if .WindowState == $wsMinimized :  .WindowState = $wsNormal
         forceforeground( this.hwnd )
      }
      .Visible = show     
      //print( "checed \(show)\n" )
      fClipTools.tbiMainWin.Checked = show 
   }      
}
//!GFG method TrayMouse evparMouse
method uint vfClipMan.TrayMouse <alias=fClipMan_TrayMouse>( evparMouse evn )//!\GFG
{
   .testtray = .testmove
   if evn.evmtype == $evmLDown
   {
      //.HideShow( !fClipTools.Visible )             
      fClipTools.Visible = !fClipTools.Visible
      fClipTools.CheckPos()
   }
return 0
}

//!GFG method Close evparQuery
method uint vfClipMan.Close <alias=fClipMan_Close>( evparQuery evn )//!\GFG
{   
   if !.flgExit && !evn.val  
   {
      .WindowState = $wsMinimized
      evn.flgCancel = 1
      return 0
   }
   if !.Visible : .WindowState = $wsMinimized
   prefs.setform( "fMain", this )
   prefs.setform( sftools, fClipTools )
   prefs.setval( sftools, "Visible", fClipTools.Visible )
   prefs.write( getdatapath( stemp, "options.gt" ))
return 0
}

//!GFG method PosChanged evparEvent
method uint vfClipMan.PosChanged <alias=fClipMan_PosChanged>( evparEvent evn )//!\GFG
{
   if .WindowState == $wsMinimized : .HideShow( 0 )
return 0
}

//!GFG method Exit evparEvent
method uint vfClipMan.Exit <alias=fClipMan_Exit>( evparEvent evn )//!\GFG
{
   .flgExit = 1
   .Close()
   .flgExit = 0
return 0
}


//!GFG method Settings evparEvent
method uint vfClipMan.Settings <alias=fClipMan_Settings>( evparEvent evn )//!\GFG
{
   if !&fPrefs.Owner
   {
      fPrefs.FormStyle = $fsModal
      fPrefs.Owner = fClipTools
   }
   fPrefs.Run( prefs )
return 0
}


//!GFG method Lang evparEvent
method uint vfClipMan.Lang <alias=fClipMan_Lang>( evparEvent evn )//!\GFG
{
   uint i
   fornum i, *.dynamics
   {
      .dynamics[i]->TVItem.Label = dynnames[i]->str.ustr()->locustr.Text( this )
   }
return 0
}

//!GFG method About evparEvent
method uint vfClipMan.About <alias=fClipMan_About>( evparEvent evn )//!\GFG
{
   fAbout.ShowModal( fClipTools )
return 0
}

//!GFG includeinit
include { $"clipman.gi" 
}//!\GFG

